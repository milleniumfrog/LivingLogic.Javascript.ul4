{"version":3,"file":"ul4.js","sources":["../../src/ul4.ts"],"sourcesContent":["export namespace helper {\n\n}\nexport namespace ul4 {\n\texport class _Set{\n\n\t\tpublic items: any;\n\n\t/**\n\t * add items to Set\n\t * @param {any[]} items \n\t */\n\t\tadd(...items: any[]) {\n\t\t\tfor (let item of items)\n\t\t\t\tthis.items[item] = true;\n\t\t}\n\t}\n\n}\n\nexport namespace ul4on {\n\t\n\t\n\tlet _registry: any = {};\n\t/**\n\t * checks if map exists when loading\n\t */\n\tconst _havemap: boolean = (typeof(Map) === \"function\" && typeof(Map.prototype.forEach) === \"function\");\n\t/**\n\t * checks if maps constructor exists when loading\n\t */\n    const _havemapconstructor: boolean = (function () {\n        if (_havemap)\n\t    {\n\t\t    try\n\t\t    {\n\t\t    \tif (new Map([[1, 2]]).size == 1)\n\t\t    \t\treturn true;\n\t\t    }\n\t\t    catch (error)\n\t\t    {\n\t\t    }\n        }\n        return false;\n\t})();\n\t/**\n\t * checks if set exists when loading\n\t */\n    const _haveset: boolean = (typeof(Set) === \"function\" && typeof(Set.prototype.forEach) === \"function\");\n\t/**\n\t * checks if set constructor exists when loading\n\t */\n\tconst _havesetconstructor: boolean = (function () {\n        if (_haveset)\n\t    {\n\t\t    try\n\t    \t{\n\t    \t\tif (new Set([1, 2]).size == 2)\n\t    \t\t\treturn true;\n\t    \t}\n\t\t    catch (error)\n\t\t    {\n\t\t    }\n        }\n        return false;\n\t})();\n\t/**\n\t * make a Maplike\n\t * @param {any[]} items \n\t */\n\tconst _makemap: (...items: any[]) => Map<any,any> | any = (function () {\n\t\tif( _havemap ) {\n\t\t\treturn function( ...items: any[] ) {\n\t\t\t\tlet map: Map<any,any> = new Map();\n\n\t\t\t\tfor (let [key, value] of items)\n\t\t\t\t\tmap.set(key, value);\n\t\t\t\treturn map;\t\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn function( ...items: any[] ) {\n\t\t\t\tlet map: any = {};\n\n\t\t\t\tfor (let [key, value] of items)\n\t\t\t\t\tmap[key] = value;\n\t\t\t\treturn map;\n\t\t\t}\n\t\t}\n\t})();\n\t/**\n\t * set a value in a Maplike\n\t */\n\tconst _setmap: (map: Map<string, any> | any, key: string, value: any) => void = (function () {\n\t\tif( _havemap ) {\n\t\t\treturn function (map: Map<string, any>, key: string, value: any) {\n\t\t\t\tmap.set(key, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn function( map: object, key: string, value: any) {\n\t\t\t\t(<any>map)[key] = value;\n\t\t\t}\n\t\t}\n\t})();\n\t/**\n\t * create empty Maplike\n\t */\n\tconst _emptymap: () => Map<string, any> | any = (function() {\n\t\tif( _havemap ) {\n\t\t\treturn function() {\n\t\t\t\treturn new Map();\n\t\t\t}\n\t\t} \n\t\telse {\n\t\t\treturn function() {\n\t\t\t\treturn <any>{};\n\t\t\t}\n\t\t}\n\t})()\n\t/**\n\t * get value for a key from a Maplike\n\t */\n\tconst _getmap: ( map: Map<string, any> |  any, key: string ) => any = (function() {\n\t\tif( _havemap ) {\n\t\t\treturn function( map: Map<string, any>, key: string) {\n\t\t\t\treturn map.get( key );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn function( map: any, key: string ) {\n\t\t\t\treturn map[key];\n\t\t\t}\n\t\t}\n\t})()\n\t/**\n\t * create empty Set\n\t */\n\tconst _emptyset: () => Set<any> | ul4._Set = (function() {\n\t\tif( _haveset ) {\n\t\t\treturn function () {\n\t\t\t\treturn new Set();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn function () {\n\t\t\t\treturn new ul4._Set();\n\t\t\t}\n\t\t}\n\t})()\n\t/**\n\t * make a set\n\t * @param {any[]} items\n\t */\n\tfunction _makeset(...items: any[]) {\n\t\tlet set: Set<any> | ul4._Set = _emptymap();\n\t\tfor( let item of items ) {\n\t\t\tset.add( item );\n\t\t}\n\t\treturn set;\n\t}\n\n\t/**\n\t * Register the constructor function ``f`` under the name ``name`` with the UL4ON machinery\n\t * @param name \n\t * @param f \n\t */\n\texport function register( name: string, f: Function ) {\n\t\tf.prototype.ul4onname = name;\n\t\t_registry[name] = f;\n\t}\n\n\t/**\n\t * Return a string that contains the object ``obj`` in the UL4ON serialization format\n\t * @param obj \n\t * @param indent \n\t */\n\texport function dumps( obj: any, indent: any ) {\n\t\tlet encoder: Encoder = new Encoder( indent );\n\t}\n\n\texport function loads( data: any, registry?: any ) {\n\t\tlet decoder: Decoder = new Decoder( data, registry );\n\t\treturn decoder.load();\n\t}\n\n\texport class Encoder {\n\t\tpublic data: any[];\n\t\tprivate _level: number;\n\t\tprivate _strings2index: any;\n\t\tprivate _ids2index: any;\n\t\tprivate _backrefs: number;\n\t\t/**\n\t\t * create a new Encoder object\n\t\t * @param ident \n\t\t */\n\t\tconstructor( public ident: any = null ) {\n\t\t\tthis.data = [];\n\t\t\tthis._level = 0;\n\t\t\tthis._strings2index = {};\n\t\t\tthis._ids2index = {};\n\t\t\tthis._backrefs = 0;\n\t\t}\n\t}\n\n\texport class Decoder {\n\t\tpublic pos: number;\n\t\tpublic backrefs: any[];\n\t\tpublic stack: any[];\n\t\tconstructor( public data: any, public registry: any = null ) {\n\t\t\tthis.pos = 0;\n\t\t\tthis.backrefs = [];\n\t\t\tthis.stack = []; // Use for informative error messages\n\t\t}\n\t\tload() {};\n\t}\n}"],"names":["ul4","_Set","_i","items","items_1","_a","item","this","ul4on","name","f","prototype","ul4onname","obj","indent","Encoder","data","registry","Decoder","load","ident","_level","_strings2index","_ids2index","_backrefs","pos","backrefs","stack"],"mappings":"yLAGA,IAAiBA,IAAAA,EAAAA,QAAAA,uBAChB,cAYA,OAJCC,gBAAA,eAAI,aAAAC,mBAAAA,IAAAC,kBACH,IAAiB,QAAAC,IAAAC,WAAAA,KAAZ,IAAIC,OACRC,KAAKJ,MAAMG,IAAQ,SAVTN,SAgBd,SAAiBQ,GAmJAA,WAAhB,SAA0BC,EAAcC,GACvCA,EAAEC,UAAUC,UAAYH,GASTD,QAAhB,SAAuBK,EAAUC,GACT,IAAIC,EAASD,IAGrBN,QAAhB,SAAuBQ,EAAWC,GAEjC,OADuB,IAAIC,EAASF,EAAMC,GAC3BE,QAGhB,MAUC,SAAoBC,gBAAAA,QAAAb,WAAAa,EACnBb,KAAKS,KAAO,GACZT,KAAKc,OAAS,EACdd,KAAKe,eAAiB,GACtBf,KAAKgB,WAAa,GAClBhB,KAAKiB,UAAY,GAfNhB,YAmBb,iBAIC,WAAoBQ,EAAkBC,gBAAAA,QAAlBV,UAAAS,EAAkBT,cAAAU,EACrCV,KAAKkB,IAAM,EACXlB,KAAKmB,SAAW,GAChBnB,KAAKoB,MAAQ,GAGf,OADCT,iBAAA,kBATYV,YAzLd,CAAiBA,UAAAA"}